<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MIT 6.828 Lab2</title>
    <link href="/2022/11/08/mit6828lab2/"/>
    <url>/2022/11/08/mit6828lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="Mit-6-828-Lab2-Memory-Management"><a href="#Mit-6-828-Lab2-Memory-Management" class="headerlink" title="Mit 6.828 Lab2 Memory Management"></a>Mit 6.828 Lab2 Memory Management</h1><p>lab2的关键文件是要实现pmap.c中的虚拟内存系统，主函数是mem_init()</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="Link-Address-和-Load-Address"><a href="#Link-Address-和-Load-Address" class="headerlink" title="Link Address 和 Load Address"></a>Link Address 和 Load Address</h3><p>待完成</p><p>程序在链接的时候，通过Link Address来指定程序代码在<strong>逻辑空间</strong>（Logical Address Space）中的地址。</p><h3 id="虚拟内存硬件-MMU"><a href="#虚拟内存硬件-MMU" class="headerlink" title="虚拟内存硬件 MMU"></a>虚拟内存硬件 MMU</h3><p>虚拟内存的功能需要配合硬件的功能实现，目的是提供一种地址转换功能。 对于x86体系来说，地址转换的流程如下图所示：<br><img src="/image/protected_mode_address_translation.png"></p><!-- <img src = "protected_mode_address_translation.png"> --><p>注意图中的Logical Address、Linear Address、Physical Address的概念。</p><h4 id="Segment-Translation"><a href="#Segment-Translation" class="headerlink" title="Segment Translation"></a>Segment Translation</h4><p>作用：略<br>是通过GDT&#x2F;LDT表来进行段转换的。<br>其中Base字段指的是段的<strong>起始地址</strong>，而Limit字段指的是段的<strong>大小</strong>。 为了简单起见，JOS的实验当中通过设置BASE地址为0x0，Limit段为0xfffff,Selector永远置为0x0，即将整个地址空间视为一个段，此时Logical Address &#x3D;&#x3D; Linear Address，在后面的实验中视为没有段转换。</p><h4 id="Page-Translation"><a href="#Page-Translation" class="headerlink" title="Page Translation"></a>Page Translation</h4><p>页表的本质是<strong>逻辑地址到物理地址的映射</strong>。<br>页转换是通过二级页表机制进行地址翻译的。CPU通过寄存器<strong>CR3</strong>上的值来获取页目录（PD）的地址。</p><p>其中Page Directory和Page Table的Entry结构如下图所示</p><p><img src="/image/pagetable.png"></p><!-- <img src= "page_trans_register.png"> --><p>PDE中存放着<strong>页表</strong>所在的<strong>物理内存</strong>地址，PTE存放的是<strong>页</strong>所在的<strong>物理内存</strong>地址。</p><h3 id="一些基本的认识"><a href="#一些基本的认识" class="headerlink" title="一些基本的认识"></a>一些基本的认识</h3><ul><li>程序的代码中变量、函数即指针等的值都是逻辑地址Logical Address，不是内存的物理地址。所有的程序都是运行在逻辑空间上的，逻辑空间中的数据和代码的分布是由程序在<strong>链接阶段</strong>就已经确定了，具体的例子可以参考ELF文件当中的Link Address和Load Address的作用。</li><li>逻辑地址到物理地址是通过页表来给定，因此内存的逻辑空间大小和物理空间大小是无关的。一个简单的推论：如果物理空间小于逻辑空间，那么就注定无法在同一时刻给所有的逻辑空间分配物理地址。</li></ul><h2 id="lab1-回顾"><a href="#lab1-回顾" class="headerlink" title="lab1 回顾"></a>lab1 回顾</h2><p>lab1中有几处关键点需要注意：</p><ul><li>内核的地址空间通常从一个<strong>逻辑空间</strong>的高地址开始，为的是将低地址留给用户使用。对于32位的x86来说，会从一个KERNBASE（0xf0000000）开始一直到4GB地址空间的结束（0xffffffff）。</li><li>但是由于物理空间的大小限制，内存很多时候是无法到达0xf0000000处的，因此在<strong>内核引导</strong>的时候，通常会把内核的代码加载到一个比较低的<strong>物理地址</strong>。在JOS中，是通过Entry.S中设置页表，将<strong>逻辑地址</strong>[KERNBASE, 2^32 )映射到物理地址的[0,2^32 - KERNBASE)，在本实验中为4MB。 这样内核就可以在最小4MB的内存下启动。</li><li>由此可知，在<strong>内核被加载之前</strong>，已经有页表的存在了！MMU的地址转换已经打开了！在内核被加载后，内核需要设置一些新的内核数据结构，以实现物理内存管理与虚拟内存系统等功能，并设置一张新的页表，最后再将CR3指向新的页目录，这才真正的转换到新的页表中去。</li></ul><h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><h3 id="mem-init函数的作用"><a href="#mem-init函数的作用" class="headerlink" title="mem_init函数的作用"></a>mem_init函数的作用</h3><p>mem_init为整个pmap.c的主函数，其主要步骤如下：</p><ol><li>由i386_detect_memory()探明物理内存空间的大小</li><li>创建新的页目录</li><li>配置物理内存页管理相关的数据结构</li><li>设置相应页表的映射</li><li>将CR3指向新的页表</li></ol><p>注意：直到第5步前，程序中所有的逻辑地址到物理地址的映射都是由entrypgdir.c中定义的，也就是Entey.S当中设置的初始页表。第5步之后才会转换成新的页表</p><h3 id="几个关键的宏"><a href="#几个关键的宏" class="headerlink" title="几个关键的宏"></a>几个关键的宏</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//物理地址与内核逻辑地址互转</span><br>PADDR(va); <span class="hljs-comment">//将逻辑地址va转换成物理地址</span><br>KADDR(pa); <span class="hljs-comment">//将物理地址pa转换成逻辑地址</span><br></code></pre></td></tr></table></figure><h3 id="Physical-Management"><a href="#Physical-Management" class="headerlink" title="Physical Management"></a>Physical Management</h3><h4 id="boot-alloc"><a href="#boot-alloc" class="headerlink" title="boot_alloc"></a>boot_alloc</h4><p>boot_alloc的作用是从内核的bss段的末尾开始，线性的分配连续的空间地址。<br>这个函数的主要是用来为后面设立虚拟内存系统创建相应的内核数据结构。<br>在JOS的设计中，这些空间会紧贴着内核代码，并常驻在内存中，不会参与到后面动态的物理内存分配。<br>注意：通常会用boot_alloc(0)来返回当前nextfree的地址（逻辑地址）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">boot_alloc</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *nextfree;<span class="hljs-comment">// virtual address of next byte of free memory</span><br><span class="hljs-type">char</span> *result;<br><br><span class="hljs-comment">// Initialize nextfree if this is the first time.</span><br><span class="hljs-comment">// &#x27;end&#x27; is a magic symbol automatically generated by the linker,</span><br><span class="hljs-comment">// which points to the end of the kernel&#x27;s bss segment:</span><br><span class="hljs-comment">// the first virtual address that the linker did *not* assign</span><br><span class="hljs-comment">// to any kernel code or global variables.</span><br><span class="hljs-keyword">if</span> (!nextfree) &#123;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> end[];<br>nextfree = ROUNDUP((<span class="hljs-type">char</span> *) end, PGSIZE);<br>&#125;<br><br><span class="hljs-comment">// Allocate a chunk large enough to hold &#x27;n&#x27; bytes, then update</span><br><span class="hljs-comment">// nextfree.  Make sure nextfree is kept aligned</span><br><span class="hljs-comment">// to a multiple of PGSIZE.</span><br>result = nextfree;<br><span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>nextfree = ROUNDUP(nextfree + n, PGSIZE);<br><span class="hljs-keyword">if</span>((<span class="hljs-type">uint32_t</span>)nextfree - KERNBASE &gt; (npages * PGSIZE))&#123;<br>panic(<span class="hljs-string">&quot;boot_alloc: out of memory. Request %uK, available %uK.\n&quot;</span><br>  ,(<span class="hljs-type">uint32_t</span>)n / <span class="hljs-number">1024</span>, npages*PGSIZE / <span class="hljs-number">1024</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>boot_alloc只在mem_init函数中用来分配<strong>页目录</strong>的还有<strong>物理页数据结构</strong>（PageInfo）的空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mem_init</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//...</span><br>    kern_pgdir = (<span class="hljs-type">pde_t</span> *) boot_alloc(PGSIZE);<br>    <span class="hljs-comment">//...</span><br>    pages = (<span class="hljs-keyword">struct</span> PageInfo *) boot_alloc(npages * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PageInfo));<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="PageInfo"><a href="#PageInfo" class="headerlink" title="PageInfo"></a>PageInfo</h4><p>内核通过PageInfo的数据结构来管理物理页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> &#123;</span><br><span class="hljs-comment">// Next page on the free list.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pp_link</span>;</span><br><br><span class="hljs-comment">// pp_ref is the count of pointers (usually in page table entries)</span><br>  <span class="hljs-comment">//物理页的引用计数</span><br><span class="hljs-type">uint16_t</span> pp_ref;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> PageInfo* <span class="hljs-title function_">pa2page</span><span class="hljs-params">(<span class="hljs-type">physaddr_t</span> pa)</span>;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">physaddr_t</span> <span class="hljs-title function_">page2pa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PageInfo *pp)</span>;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span>* <span class="hljs-title function_">page2kva</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PageInfo *pp)</span>;<br></code></pre></td></tr></table></figure><p>问题：  这里就涉及到一个问题，怎么计算出PageInfo所指的是哪一片物理页呢？<br>答：    由上面mem_init可知，PageInfo是被<strong>集中存放</strong>在一段<strong>连续的数组pages</strong>中的，根据PageInfo在<strong>数组中的所在位置</strong>即可计算得出所指的物理页。 例如pages[0]的PageInfo所代表的就是物理页0。</p><h4 id="区分page2pa-pp-和PADDR-pp"><a href="#区分page2pa-pp-和PADDR-pp" class="headerlink" title="区分page2pa(pp)和PADDR(pp)"></a>区分page2pa(pp)和PADDR(pp)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> * <span class="hljs-title">pp</span> =</span> ...;<br><span class="hljs-comment">//pp所代表物理页的物理地址</span><br><span class="hljs-type">physaddr_t</span> addr1 = page2pa(pp);<br><span class="hljs-comment">//pp数据结构所在的物理地址</span><br><span class="hljs-type">physaddr_t</span> add2 =  PADDR(pp);<br></code></pre></td></tr></table></figure><h4 id="page-init"><a href="#page-init" class="headerlink" title="page_init"></a>page_init</h4><p>作用：初始化pages数组中的PageInfo。通过链表的头插法来维护空闲的物理页，page_free_list全局变量所指即为链表头。<br>其中物理地址空间的结构如图所示：</p><!-- ![](@attachment/Clipboard_2022-11-06-00-57-39.png) --><p><img src="/image/physical.png"></p><ul><li>物理内存中某些地址是用来进行VGA的IO、或者存储了BIOS程序，因此这些物理页<strong>永远</strong>也不能分配出去，需要避开。</li><li>注：物理地址空间的结构是计算机体系相关的，此处为x86结构。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">page_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>page_free_list = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">size_t</span> i;<br>  <span class="hljs-comment">//  1) Mark physical page 0 as in use.</span><br><span class="hljs-comment">//     This way we preserve the real-mode IDT and BIOS structures</span><br><span class="hljs-comment">//     in case we ever need them.  (Currently we don&#x27;t, but...)</span><br>pages[<span class="hljs-number">0</span>].pp_ref = <span class="hljs-number">1</span>;<br>  <br>  <span class="hljs-comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span><br><span class="hljs-comment">//     is free.</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i&lt; npages_basemem; i++)&#123;<br>pages[i].pp_ref = <span class="hljs-number">0</span>;<br>pages[i].pp_link = page_free_list;<br>page_free_list = &amp;pages[i];<br>&#125;<br><br><span class="hljs-comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span><br><span class="hljs-comment">//     never be allocated.</span><br><span class="hljs-keyword">for</span>(i = PGNUM(IOPHYSMEM); i &lt; PGNUM(EXTPHYSMEM); i++)&#123;<br>pages[i].pp_ref = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span><br>  <span class="hljs-comment">//  这段区域有些内存可用有些内存不可用</span><br>  <span class="hljs-comment">//  其中该区域存放着内核的代码和数据，内核被加载在BIOS的上方，因此内核区域需要避开，这段区域是常驻内存的。</span><br>  <span class="hljs-comment">//  可以用过boot_alloc(0)来获得内核区域的末尾，也就是nextfree所指的位置。</span><br><span class="hljs-keyword">for</span>(; i &lt; npages; i++)&#123;<br><span class="hljs-comment">// 内核代码和数据。注意此处需要用PADDR()宏，回顾上面的论述，nextfree所指的是逻辑地址，</span><br>    <span class="hljs-comment">// 是在KERNBASE以上的，而由于由entrydir页表的存在，KERNBASE内存被映射到了物理地址的0地址处，因此这里不能忘记转换。</span><br>    <span class="hljs-keyword">if</span>(i&lt; PGNUM(PADDR(boot_alloc(<span class="hljs-number">0</span>))))&#123;<br>pages[i].pp_ref = <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>pages[i].pp_ref = <span class="hljs-number">0</span>;<br>pages[i].pp_link = page_free_list;<br>page_free_list = &amp;pages[i];<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述的函数对pages进行初始化后，free_page_lists链表中存储的就是<strong>物理内存</strong>中所有可以用来被分配的页了，之后物理页的分配将全部通过下面的page_*函数进行分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> PageInfo * <span class="hljs-title function_">page_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br><span class="hljs-keyword">if</span>(!page_free_list) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span>* <span class="hljs-title">result</span>;</span><br>result = page_free_list;<br>page_free_list = page_free_list-&gt;pp_link;<br>result-&gt;pp_link = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span>(alloc_flags &amp; ALLOC_ZERO)&#123;<br>    <span class="hljs-comment">//因为程序运行在逻辑空间上，因此是result所指物理页的逻辑地址，page2kva()</span><br><span class="hljs-built_in">memset</span>(page2kva(result), <span class="hljs-number">0x0</span>, PGSIZE);<br>&#125;<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">//仅仅将page放回空闲队列中</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">page_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PageInfo *pp)</span><br>&#123;<br><span class="hljs-keyword">if</span>(pp-&gt;pp_ref != <span class="hljs-number">0</span>)&#123;<br>panic(<span class="hljs-string">&quot;page_free: pp-&gt;pp_ref is nonzero! ref_count: %u\n&quot;</span>,pp-&gt;pp_ref);<br>&#125;<br><span class="hljs-keyword">if</span>(pp-&gt;pp_link)&#123;<br>panic(<span class="hljs-string">&quot;page_free: pp-&gt;pp_link is not NULL! Tried to free page in free list!\n&quot;</span>);<br>&#125;<br>pp-&gt;pp_link = page_free_list;<br>page_free_list = pp;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">page_decref</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PageInfo* pp)</span><br>&#123;<br><span class="hljs-keyword">if</span> (--pp-&gt;pp_ref == <span class="hljs-number">0</span>)<br>page_free(pp);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Virtual-Management"><a href="#Virtual-Management" class="headerlink" title="Virtual Management"></a>Virtual Management</h3><h4 id="虚拟内存的结构"><a href="#虚拟内存的结构" class="headerlink" title="虚拟内存的结构"></a>虚拟内存的结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//memlayout.h</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Virtual memory map:                                Permissions</span><br><span class="hljs-comment"> *                                                    kernel/user</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *    4 Gig --------&gt;  +------------------------------+</span><br><span class="hljs-comment"> *                     |                              | RW/--</span><br><span class="hljs-comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment"> *                     :              .               :</span><br><span class="hljs-comment"> *                     :              .               :</span><br><span class="hljs-comment"> *                     :              .               :</span><br><span class="hljs-comment"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--</span><br><span class="hljs-comment"> *                     |                              | RW/--</span><br><span class="hljs-comment"> *                     |   Remapped Physical Memory   | RW/--</span><br><span class="hljs-comment"> *                     |                              | RW/--</span><br><span class="hljs-comment"> *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+</span><br><span class="hljs-comment"> *    KSTACKTOP        |     CPU0&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span><br><span class="hljs-comment"> *                     | - - - - - - - - - - - - - - -|                   |</span><br><span class="hljs-comment"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span><br><span class="hljs-comment"> *                     +------------------------------+                   |</span><br><span class="hljs-comment"> *                     |     CPU1&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span><br><span class="hljs-comment"> *                     | - - - - - - - - - - - - - - -|                 PTSIZE</span><br><span class="hljs-comment"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span><br><span class="hljs-comment"> *                     +------------------------------+                   |</span><br><span class="hljs-comment"> *                     :              .               :                   |</span><br><span class="hljs-comment"> *                     :              .               :                   |</span><br><span class="hljs-comment"> *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</span><br><span class="hljs-comment"> *                     |       Memory-mapped I/O      | RW/--  PTSIZE</span><br><span class="hljs-comment"> * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span><br><span class="hljs-comment"> *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE</span><br><span class="hljs-comment"> *    UVPT      ----&gt;  +------------------------------+ 0xef400000</span><br><span class="hljs-comment"> *                     |          RO PAGES            | R-/R-  PTSIZE</span><br><span class="hljs-comment"> *    UPAGES    ----&gt;  +------------------------------+ 0xef000000</span><br><span class="hljs-comment"> *                     |           RO ENVS            | R-/R-  PTSIZE</span><br><span class="hljs-comment"> * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span><br><span class="hljs-comment"> * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE</span><br><span class="hljs-comment"> *                     +------------------------------+ 0xeebff000</span><br><span class="hljs-comment"> *                     |       Empty Memory (*)       | --/--  PGSIZE</span><br><span class="hljs-comment"> *    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000</span><br><span class="hljs-comment"> *                     |      Normal User Stack       | RW/RW  PGSIZE</span><br><span class="hljs-comment"> *                     +------------------------------+ 0xeebfd000</span><br><span class="hljs-comment"> *                     |                              |</span><br><span class="hljs-comment"> *                     |                              |</span><br><span class="hljs-comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment"> *                     .                              .</span><br><span class="hljs-comment"> *                     .                              .</span><br><span class="hljs-comment"> *                     .                              .</span><br><span class="hljs-comment"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|</span><br><span class="hljs-comment"> *                     |     Program Data &amp; Heap      |</span><br><span class="hljs-comment"> *    UTEXT --------&gt;  +------------------------------+ 0x00800000</span><br><span class="hljs-comment"> *    PFTEMP -------&gt;  |       Empty Memory (*)       |        PTSIZE</span><br><span class="hljs-comment"> *                     |                              |</span><br><span class="hljs-comment"> *    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+</span><br><span class="hljs-comment"> *                     |       Empty Memory (*)       |                   |</span><br><span class="hljs-comment"> *                     | - - - - - - - - - - - - - - -|                   |</span><br><span class="hljs-comment"> *                     |  User STAB Data (optional)   |                 PTSIZE</span><br><span class="hljs-comment"> *    USTABDATA ----&gt;  +------------------------------+ 0x00200000        |</span><br><span class="hljs-comment"> *                     |       Empty Memory (*)       |                   |</span><br><span class="hljs-comment"> *    0 ------------&gt;  +------------------------------+                 --+</span><br></code></pre></td></tr></table></figure><h4 id="PDE和PTE的结构"><a href="#PDE和PTE的结构" class="headerlink" title="PDE和PTE的结构"></a>PDE和PTE的结构</h4><!-- ![](@attachment/Clipboard_2022-11-06-01-30-31.png) --><p><img src="/image/page_trans_register.png"></p><h4 id="权限管理注解"><a href="#权限管理注解" class="headerlink" title="权限管理注解"></a>权限管理注解</h4><p>PDE的权限和PTE的权限</p><h4 id="pgdir-walk"><a href="#pgdir-walk" class="headerlink" title="pgdir_walk"></a>pgdir_walk</h4><p>首先看函数的注释和实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Given &#x27;pgdir&#x27;, a pointer to a page directory, pgdir_walk returns</span><br><span class="hljs-comment">// a pointer to the page table entry (PTE) for linear address &#x27;va&#x27;.</span><br><span class="hljs-comment">// This requires walking the two-level page table structure.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The relevant page table page might not exist yet.</span><br><span class="hljs-comment">// If this is true, and create == false, then pgdir_walk returns NULL.</span><br><span class="hljs-comment">// Otherwise, pgdir_walk allocates a new page table page with page_alloc.</span><br><span class="hljs-comment">//    - If the allocation fails, pgdir_walk returns NULL.</span><br><span class="hljs-comment">//    - Otherwise, the new page&#x27;s reference count is incremented,</span><br><span class="hljs-comment">//the page is cleared,</span><br><span class="hljs-comment">//and pgdir_walk returns a pointer into the new page table page.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint 1: you can turn a PageInfo * into the physical address of the</span><br><span class="hljs-comment">// page it refers to with page2pa() from kern/pmap.h.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint 2: the x86 MMU checks permission bits in both the page directory</span><br><span class="hljs-comment">// and the page table, so it&#x27;s safe to leave permissions in the page</span><br><span class="hljs-comment">// directory more permissive than strictly necessary.</span><br><span class="hljs-comment">// 也就是说PDE可以把所有的权限都开了，即PTE_U | PTE_W,</span><br><span class="hljs-comment">// 而更加细粒度的权限管理应该放到PTE当中去。</span><br><span class="hljs-comment">// 注意：PDE的权限必须要大于所指页表中的所有PTE的权限，否则PTE的权限无意义，</span><br><span class="hljs-comment">// 而且访问会导致CPU宕机。因为x86CPU会同时检查PDE和PTE的权限，如果给了</span><br><span class="hljs-comment">// PDE只读，再给PTE读写的话将毫无意义。因为在分配页目录的时候，还不知道用户要如何</span><br><span class="hljs-comment">// 规定PTE中的权限，因此不应该提前在PDE当中就提早做出严格的限定。PDE权限可以相对宽松，</span><br><span class="hljs-comment">// 而细致的权限管理放到PTE创建的时候再进行限定。</span><br><span class="hljs-comment">// 考虑另一种情况： 如果PDE不给PTE_W，则意味着该PDE所指的PT不可修改，</span><br><span class="hljs-comment">// 那么是不是意味着这个PT管理的所有地址都没用了...</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint 3: look at inc/mmu.h for useful macros that manipulate page</span><br><span class="hljs-comment">// table and page directory entries.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">pte_t</span> *<br><span class="hljs-title function_">pgdir_walk</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> create)</span><br>&#123;<br><span class="hljs-type">pte_t</span> * result;<br><span class="hljs-keyword">if</span>((pgdir[PDX(va)] &amp; PTE_P) == <span class="hljs-number">0x0</span>)&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span>* <span class="hljs-title">pp</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span>(create)&#123;<br>pp = page_alloc(ALLOC_ZERO);<br>&#125;<br><span class="hljs-keyword">if</span>(!pp) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// out of memory</span><br>++pp-&gt;pp_ref; <span class="hljs-comment">//increase pp-&gt;ref</span><br><span class="hljs-comment">//give all the permission to PDE, important!!!</span><br>pgdir[PDX(va)] = page2pa(pp) | PTE_P | PTE_U | PTE_W;<br>&#125;<br><br>  <span class="hljs-comment">//注意pte_t* 是32bit, 4Bytes, 也就是说如果用地址偏移的方式的话</span><br>  <span class="hljs-comment">//应当是 result = (pte + 4 * PTX(va));</span><br><span class="hljs-type">pte_t</span> * pte = KADDR(PTE_ADDR(pgdir[PDX(va)]));<br>result = &amp;pte[PTX(va)];<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mapreduce</title>
    <link href="/2022/05/03/mapreduce/"/>
    <url>/2022/05/03/mapreduce/</url>
    
    <content type="html"><![CDATA[<h1 id="Mit-6-824-Lab-1-Mapreduce-实验报告"><a href="#Mit-6-824-Lab-1-Mapreduce-实验报告" class="headerlink" title="Mit 6.824 Lab 1 Mapreduce 实验报告"></a>Mit 6.824 Lab 1 Mapreduce 实验报告</h1><p>lab1的主要目的就是熟悉GO语言, 难度适中</p><h2 id="Mapreduce主要思想"><a href="#Mapreduce主要思想" class="headerlink" title="Mapreduce主要思想"></a>Mapreduce主要思想</h2><p>map     (k1,v1)          -&gt; list(k2,v2)<br>reduce  (k2,list(v2))    -&gt; list(v2)</p><ul><li>Map<br>  取key&#x2F;value pairs (k1,v1), 并通过Map操作产生一个中间k&#x2F;v集合list(k2,v2). Mapreduce库将所有具有相同的intermediate key $I$的值收集起来,形成一个k2对应的集合list(v2), 并将其传递给reduce函数.</li><li>Reduce<br>  接受一个Intermediate key $I$ (k2), 及其值的集合list(v2). reduce操作合并集合中所有的值,并产生一个较小的集合list(v2)–通常来说每个reduce操作只会产生零个或一个输出值. 即len(list(v2)) &#x3D;&#x3D; 0 or 1</li></ul><h3 id="例子-单词计数"><a href="#例子-单词计数" class="headerlink" title="例子: 单词计数"></a>例子: 单词计数</h3><p>假设有很多文件, 每个文件包含很多的单词. 为了统计文件中单词的个数, 可设计如下的Map-Reduce操作    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java">map(String key, String value):<br>    <span class="hljs-comment">// key:     document name</span><br>    <span class="hljs-comment">// value:   document content</span><br>    <span class="hljs-keyword">for</span> each word w in value:<br>        EmitIntermediate(w,<span class="hljs-string">&quot;1&quot;</span>);<br>    <br><span class="hljs-comment">//具有相同w键的值会被收集起来,传递到reduce中</span><br><span class="hljs-comment">//如reduce接受到的key为apple, 而values 为[&quot;1&quot;,...,&quot;1&quot;]</span><br><br>reduce(String key, Iterator values):<br>    <span class="hljs-comment">// key : a word</span><br>    <span class="hljs-comment">// values: a list of counts</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> each v in values:<br>        result += ParseInt(v);<br>    Emit(AsString(result));<br>    <span class="hljs-comment">//这里的reduce最终输出其实就是单词的个数</span><br></code></pre></td></tr></table></figure><h2 id="Mapreduce实验"><a href="#Mapreduce实验" class="headerlink" title="Mapreduce实验"></a>Mapreduce实验</h2><h3 id="串行化的Mapreduce-–-单词计数"><a href="#串行化的Mapreduce-–-单词计数" class="headerlink" title="串行化的Mapreduce – 单词计数"></a>串行化的Mapreduce – 单词计数</h3><ol><li>对于每个文件运行一次Map操作, Map操作生成一个数组kva, 包含了所有的键值对, 然后append进intermediate的列表中.</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Go">   intermediate := []mr.KeyValue&#123;&#125;<br><span class="hljs-keyword">for</span> _, filename := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">2</span>:] &#123;<br><span class="hljs-comment">//...代码省略</span><br>kva := mapf(filename, <span class="hljs-type">string</span>(content))<br>intermediate = <span class="hljs-built_in">append</span>(intermediate, kva...)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>对intermediate按照key的大小进行排序.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go">sort.Sort(ByKey(intermediate))<br></code></pre></td></tr></table></figure></li><li><p>将key相同的value值聚合在一起, 并通过reducef得到最后的输出,并保存在ofile中. 即统计intermediate中有多少个[key, “1”]</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Go">   <span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(intermediate) &#123;<br>j := i + <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> j &lt; <span class="hljs-built_in">len</span>(intermediate) &amp;&amp; intermediate[j].Key == intermediate[i].Key &#123;<br>j++<br>&#125;<br>values := []<span class="hljs-type">string</span>&#123;&#125;<br><span class="hljs-keyword">for</span> k := i; k &lt; j; k++ &#123;<br>values = <span class="hljs-built_in">append</span>(values, intermediate[k].Value)<br>&#125;<br>output := reducef(intermediate[i].Key, values)<br><br><span class="hljs-comment">// this is the correct format for each line of Reduce output.</span><br>fmt.Fprintf(ofile, <span class="hljs-string">&quot;%v %v\n&quot;</span>, intermediate[i].Key, output)<br><br>i = j<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分布式Mapreduce"><a href="#分布式Mapreduce" class="headerlink" title="分布式Mapreduce"></a>分布式Mapreduce</h3><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><p>主要的框架分为两种进程, Coordinator和多个Workers.<br>采用生产者消费者模式:</p><ul><li>Coordinator: 生产者, 产生需要执行的任务</li><li>Workers : 消费者, 消费从Coordinator获取的任务<br><img src="/image/mapreduce.jpg"></li></ul><h5 id="Map阶段"><a href="#Map阶段" class="headerlink" title="Map阶段"></a>Map阶段</h5><p>Mapper读取输入文件的切片split#, 并通过mapf处理, 每个Mapper生成NReduce个中间文件(保存在本地). Mapper产生的kv经过key的hash后,会被放到指定的中间文件中. 每个Mapper产生的相同的Key只能出现在一个中间文件中. 这些中间文件在Reduce阶段只会由一个Reducer进行处理.</p><h5 id="Reduce阶段"><a href="#Reduce阶段" class="headerlink" title="Reduce阶段"></a>Reduce阶段</h5><p>假设有M个mapper, R个Reducer. 第m个Mapper产生的第r个reduced中间文件用 <code>Inter[m][r]</code>表示. 那么对于每个Reducer <code>r</code>, 首先会合并所有Mapper产生的<code>r</code>号文件, 即<code>[Inter[0][r], .., Inter[m-1][r]]</code>. 并对合并的数据进行汇集, 将具有相同Key的Value形成一个列表, 即前文所属的(k2,list(v2)). 再通过reduce函数生成最后的结果.</p><p>注意:</p><ul><li>通常多个Workers会分布在多个机器当中, 通过RPC与Coordinator进行通信. (本实验所有进程运行在一个机子上.)</li><li>如果一个Worker超时未完成任务(比如机器down了),  Coordinator应该知晓,并将相同的任务分配给另一个Worker去完成.</li></ul><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><p>课程要求不能公开源码, 这里主要提几点设计的要点:</p><ul><li><p>Coordinator与Worker之间通过RPC通信. 主要有两个调用函数 GetTasks和FinishedTasks. GetTasks从Coordinator中获取任务, FinishedTasks用于通知Coordinator任务已完成. RPC使用Task结构体传递信息.<br>  Tasks结构体主要包含以下信息(注意RPC类型首字母要大写):</p><ul><li>Task_idx (表示任务的序号, 用以区分不同的Mapper或Reducer)</li><li>Task_Type (用以标识任务的类型:Mapping, Reducing 和 Finishing)</li><li>NReduce</li><li>NMap</li><li>File_name (处理的文件名)</li><li>Begin_Timestamp (任务开始的时间)</li></ul></li><li><p>Coordinator需要知晓Worker宕机. 主要的实现就是当Worker在分配任务一段时间后没有完成任务(如10s), Coordinator则认为Worker崩溃,需要将任务重新分配给另一个Worker执行.<br>为了实现此项功能, Coordinator维护两个队列 </p><ul><li>Tasks_Ready: 表示待分配的任务, 用一个带缓存的Channel实现, 可通过阻塞实现同步.</li><li>Tasks_Assigned: 表示已分配但未完成的任务, 用map进行存储, 能够通过idx进行快速的查找</li></ul></li></ul><p>在Worker调用GetTasks后, Coordinator会添加一个10s定时器, 并保存在map容器中,通过Tasks_Key查询. 如果任务按时完成, 那么在FinishedTasks的调用中会从map当中获取其对应的计时器, 并取消计时. 若任务没有按时完成, 定时器超时后回调TimeoutHandler, 将超时的Tasks重新放入Tasks_Ready队列,等待其他Worker获取.</p><ul><li>任务完成时Worker需要传回的Task结构体, Coordinator需要对比传回Task的Begin_TimeStamp与Tasks_Assigned队列当中的Begin_TimeStamp是否一致. 如果不一致说明是因为历史的超时Worker返回的结果. 那么则忽略这次结果. (此实现有点粗糙)</li></ul><p>Reduce阶段需要在Map阶段后执行, 因此Coordinator会记录完成的Map任务数, 所有的Map完成后再往Tasks_ready队列中加入Reduce的任务.</p>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raft</title>
    <link href="/2022/05/03/raft/"/>
    <url>/2022/05/03/raft/</url>
    
    <content type="html"><![CDATA[<h1 id="Raft-共识算法"><a href="#Raft-共识算法" class="headerlink" title="Raft 共识算法"></a>Raft 共识算法</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在分布式场景中, 即使机器发生故障的概率很小, 但当主机数很大时(如成千上万时), 总会有个别的主机会出现故障. 为了保证在个别机器故障时, 整个分布式系统依然能够正常对外服务, 这就需要通过一些冗余的机制去实现. 这被称为分布式系统的容错性(Fault Tolerance).<br>主要的办法就是通过”复制”(Replication)的手段, 复制一份或多份状态(数据)的副本, 并分布到不同的机器当中, 当机器故障时, 存有副本的机器就能及时上线(Go lives), 接替故障机器的工作.<br>主要的Repliacation有两种类型:</p><h5 id="State-Transfer"><a href="#State-Transfer" class="headerlink" title="State Transfer :"></a>State Transfer :</h5><p>直接复制内存的数据, 对整个数据副本进行拷贝, 通常消耗较大.</p><h5 id="Replicated-State-Machine"><a href="#Replicated-State-Machine" class="headerlink" title="Replicated State Machine"></a>Replicated State Machine</h5><p>对外部事件进行复制, 如外部的读写时间. 根据状态复制的层级不同, 主要有两种做法:</p><ul><li>复制应用层面的状态. 如GFS</li><li>复制机器层面的状态, 完全复制一台机器的寄存器, 中断信号等. 被称为虚拟机(Virtual Machine)</li></ul><p>目前主要的技术都集中在Replacated State Machine 上. 主要的难点在于, 如何保证主机Primary与从机replica(s)之间状态的一致性?(Consistency).</p><h3 id="一致性问题发生在哪"><a href="#一致性问题发生在哪" class="headerlink" title="一致性问题发生在哪?"></a>一致性问题发生在哪?</h3><p>假设下图的一个场景. 拥有一主一从的分布式系统中, 假设有两个Client(C1, C2)分别对变量x进行写入操作Wx, C1将1写入x中: Wx1, C2将2 写入x中: Wx2. 在一个坏的设计中, 如果不经过一致性的保护, C1, C2仅仅只是分别的将两个请求同时发送到主从服务器中. 但是由于网络的不确定性, 并不能保证Wx1与Wx2两个操作到达Server1与Server2的顺序是否一致. 若顺序不一致, 就会导致主从服务器X变量的值不同, 这就产生了<strong>不一致性</strong>.</p><p>而Raft算法就是一种解决主从复制一致性的分布式共识算法.</p><h2 id="Raft-分布式共识算法"><a href="#Raft-分布式共识算法" class="headerlink" title="Raft 分布式共识算法"></a>Raft 分布式共识算法</h2><blockquote><p>论文链接<br>Diego Ongaro and John Ousterhout. 2014. In search of an understandable consensus algorithm. In <i>Proceedings of the 2014 USENIX conference on USENIX Annual Technical Conference</i> (<i>USENIX ATC’14</i>). USENIX Association, USA, 305–320.<br><a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf</a></p></blockquote><p>-强烈推荐先看Raft的动画演示, 对Raft的有一个整体的印象, 再去看论文的细节. 推荐一个动画演示的网站:<br><a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p><ul><li>a lab guidance written by the Teaching Asistance of MIT 6.824, in which you may find it very helpful during implementng the lab: <a href="https://thesquareplanet.com/blog/students-guide-to-raft/">https://thesquareplanet.com/blog/students-guide-to-raft/</a></li></ul><h3 id="提出背景与Paxos"><a href="#提出背景与Paxos" class="headerlink" title="提出背景与Paxos"></a>提出背景与Paxos</h3><p>… 待完善</p><h4 id="Raft算法基础"><a href="#Raft算法基础" class="headerlink" title="Raft算法基础"></a>Raft算法基础</h4><p>对于任何一个时刻, 每个服务器只能以下三种状态之一: </p><ul><li>Leader</li><li>Follower</li><li>Candidate<br>通常情况下只有1个Leader, 剩下的服务器都是Follower. Follower只被动的接收来自Leader和Candidate的请求,而自身不发出请求. 所有来自客户端的请求都由Leader进行处理, (若客户端请求了一个Floower, 其会重定向至其Leader). Candidate是为了选举出一个新的Leader而存在的状态. 状态之间的转移如图:<br><img src="/image/ServerStates.png"><!-- <img src = "ServerStates.png"> --></li></ul><p>每个服务器会存储一个current term数字, 表示当前任期的编号, 这个编号随着时间单调递增. 这个任期编号会在不同的服务器进行交换. 分三种情况:</p><ul><li>如果当前服务器的current term小于其他服务器的term, 那么它就会更新自己的term到一个更大的值</li><li>如果一个Leader或者Candidate发现自己的term过期了, 那么就会立即回到Follower的身份</li><li>如果一个server收到了一个过时term的请求, 它会直接拒绝</li></ul><p>服务器之间采用RPC进行通信, 主要有两个调用:</p><ul><li>RequestVote: 被Candidate用来进行Leader选举</li><li>AppendEntries: 由Leader向其他replicas复制日志条目的副本. 同时用来发送心跳信号.</li></ul><h4 id="Raft算法需要保证的一些性质"><a href="#Raft算法需要保证的一些性质" class="headerlink" title="Raft算法需要保证的一些性质"></a>Raft算法需要保证的一些性质</h4><p>在了解算法之前, 先了解下Raft算法所要实现的目标是什么,主要由以下五条:</p><ul><li><strong>Election Safty</strong>: 每个任期只能有一个Leader</li><li><strong>Leader Append-Only</strong>: Leader永远不会重写和删除它日志中的条目, 只会append新的条目. 也就是说Leader对日志拥有领导权.</li><li><strong>Log Matching</strong>: 如果两个日志当中有两条index与term都相同的条目, 那么所有小于等于该index的日志条目都是确定唯一的</li><li><strong>Leader Completeness</strong>: 如果一个日志条目已经在某一term提交了,那么在接下来的任期(higher-numbered terms)的Leader中都会包含此条目. 即无论下一个Leader是谁, 他的log当中都应该包含系统中所有已提交的日志条目</li><li><strong>State Machine Safety</strong>: 如果一个服务器已经将日志条目应用到state machine去了, 那么任何其他服务器都不能提交一个具有相同index的不同条目. 即所有对State Machine的提交都是一致的.</li></ul><h4 id="Leader-Election"><a href="#Leader-Election" class="headerlink" title="Leader Election"></a>Leader Election</h4><p>所有的servers都从Follower角色开始. 只要一个server持续收到来自Leader的心跳信号, 那么它就会一直保持Follower的状态. Leader会周期性的通过发送心跳信号(通过没有log entreis的AppendEntries RPC)来保持自己的统治地位. 如果一个Follower一段时间都没有收到心跳信号, 就会触发超时, 称为<strong>Election Timeout</strong>, 此时服务器就会认为Leader已挂, 并开始选举一个新的Leader.</p><h5 id="Election的流程"><a href="#Election的流程" class="headerlink" title="Election的流程"></a>Election的流程</h5><ul><li>follower首先自增自己的current term,并转变成candidate身份</li><li>candidate投自己一票, 并向集群中的其他服务器并发的发送Request Vote RPC.</li><li>candidate会一直处于自己的状态, 直到下列三件事发生:<ul><li>赢下选举</li><li>其他服务器确立了自己的leader地位</li><li>一段时间后没有winner</li></ul></li></ul><h6 id="赢下选举"><a href="#赢下选举" class="headerlink" title="赢下选举"></a>赢下选举</h6><p>…</p><h6 id="其他服务器赢下选举"><a href="#其他服务器赢下选举" class="headerlink" title="其他服务器赢下选举"></a>其他服务器赢下选举</h6><p>在等待选举的过程中, candidate可能会收到其他服务器的AppendEntries RPC, 即有其他服务器宣称自己是leader, 如果leader的term大于等于candidate的current term, 那么candidate就认为leader是合法的,并回到follower状态</p><h6 id="Split-Vote"><a href="#Split-Vote" class="headerlink" title="Split Vote"></a>Split Vote</h6><p>一段时间后, candidate们之间的投票意见不一,选举超时. 通常会在所有candidate在同一时间开始选举时发生. 再超时后, current term自增, 新的一轮选举会开始.</p><p>为了解决candidate同时开始选举而产生的Split Vote现象, Raft设计election timeout的时间为一个区间随机值, 比如在150 ~ 300 ms之间.</p>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
